#include "hardswish_metax.h"
#include "../../../elementwise/metax/elementwise_metax.h"
#include "../../../../utils/custom_types.h"
#include <type_traits>

namespace op::hardswish::metax {

// HardSwish function for different data types
template <typename T>
__device__ __forceinline__ T hardswish_func(const T &x) {
    if constexpr (std::is_same_v<T, half>) {
        // For half type, use float for intermediate calculations
        float x_float = __half2float(x);
        float x_plus_3 = x_float + 3.0f;
        float relu6_result = fminf(fmaxf(x_plus_3, 0.0f), 6.0f);
        float result = x_float * relu6_result / 6.0f;
        return __float2half(result);
    } else if constexpr (std::is_same_v<T, cuda_bfloat16>) {
        // For bfloat16 type, use double for higher precision intermediate calculations
        double x_double = static_cast<double>(__bfloat162float(x));
        double x_plus_3 = x_double + 3.0;
        double relu6_result = fmin(fmax(x_plus_3, 0.0), 6.0);
        double result = x_double * relu6_result / 6.0;
        return __float2bfloat16(static_cast<float>(result));
    } else {
        // For float and other types
        T x_plus_3 = x + static_cast<T>(3.0);
        T relu6_result = fminf(fmaxf(x_plus_3, static_cast<T>(0.0)), static_cast<T>(6.0));
        return x * relu6_result / static_cast<T>(6.0);
    }
}

// HardSwish operator for MetaX backend
typedef struct HardSwishOp {
public:
    static constexpr size_t num_inputs = 1;

    template <typename T>
    __device__ __forceinline__ T operator()(const T &x) const {
        return hardswish_func(x);
    }
} HardSwishOp;

Descriptor::~Descriptor() = default;

infiniStatus_t Descriptor::create(
    infiniopHandle_t handle_,
    Descriptor **desc_ptr,
    infiniopTensorDescriptor_t out_desc,
    std::vector<infiniopTensorDescriptor_t> input_desc_vec) {

    auto handle = reinterpret_cast<device::metax::Handle *>(handle_);
    auto dtype = out_desc->dtype();

    const auto &x_desc = input_desc_vec.at(0);
    const auto &y_shape = out_desc->shape();
    const auto &x_shape = x_desc->shape();

    CHECK_DTYPE(dtype, INFINI_DTYPE_F16, INFINI_DTYPE_F32, INFINI_DTYPE_BF16);

    CHECK_SAME_SHAPE(y_shape, x_shape);

    // create metax elementwise descriptor
    CREATE_ELEMENTWISE_METAX_DESCRIPTOR(handle, dtype, out_desc, input_desc_vec);

    return INFINI_STATUS_SUCCESS;
}

infiniStatus_t Descriptor::calculate(
    void *workspace,
    size_t workspace_size,
    void *output,
    std::vector<const void *> inputs,
    void *stream) const {

    if (workspace_size < _workspace_size) {
        return INFINI_STATUS_INSUFFICIENT_WORKSPACE;
    }

    switch (_dtype) {
    case INFINI_DTYPE_F16:
        return _device_info->calculate<256, HardSwishOp, half>(_info, workspace, output, inputs, stream);
    case INFINI_DTYPE_BF16:
        return _device_info->calculate<256, HardSwishOp, cuda_bfloat16>(_info, workspace, output, inputs, stream);
    case INFINI_DTYPE_F32:
        return _device_info->calculate<256, HardSwishOp, float>(_info, workspace, output, inputs, stream);
    default:
        return INFINI_STATUS_BAD_TENSOR_DTYPE;
    }

    return INFINI_STATUS_SUCCESS;
}

} // namespace op::hardswish::metax